/**
 * Simple Multi-Model Debate using aliases
 * No complex setup - just run different Claude aliases
 */

const { promisify } = require('util');
const { exec: execCallback } = require('child_process');
const exec = promisify(execCallback);
const fs = require('fs').promises;
const path = require('path');

class SimpleDebate {
  constructor() {
    // Define model aliases - from ORIGINAL PLAN
    this.models = [
      { alias: 'k1', command: 'k1', name: 'Claude Opus 4', role: 'Architecture', expertise: 'Architecture and system design' },
      { alias: 'k2', command: 'k2', name: 'GPT-5 Pro', role: 'Testing', expertise: 'Testing strategies and debugging' },
      { alias: 'k3', command: 'k3', name: 'Qwen 3 Max', role: 'Algorithms', expertise: 'Algorithm optimization' },
      { alias: 'k4', command: 'k4', name: 'Gemini Pro 2.5', role: 'Integration', expertise: 'Integration and completeness' }
    ];
    
    // c1/c2/c3 are existing Claude Code CLI with Opus (unchanged)
    // Use c1 as arbitrator if available for final synthesis
    this.arbitrator = { alias: 'c1', name: 'Claude Opus (existing)', role: 'Final Synthesis' };
    
    this.tempDir = '/tmp/simple-debate';
    this.logsDir = '/opt/mcp/servers/debate-consensus/logs';
  }

  async initialize() {
    await fs.mkdir(this.tempDir, { recursive: true });
  }

  /**
   * Run debate using k1-k4 aliases
   */
  async runDebate(question, projectPath = process.cwd()) {
    await this.initialize();
    
    console.log('🎯 Multi-Model Debate Consensus\n');
    console.log('📍 Project:', projectPath);
    console.log('❓ Question:', question);
    console.log('🤖 Models:', this.models.map(m => `${m.alias}=${m.name}`).join(', '));
    console.log('\n' + '='.repeat(70) + '\n');
    
    // Round 1: Get proposals from k1-k4
    console.log('🔄 ROUND 1: Independent Analysis\n');
    const proposals = await this.getProposals(question, projectPath);
    
    // Check if we have enough responses
    if (Object.keys(proposals).length < 2) {
      throw new Error(`Not enough models responded. Got ${Object.keys(proposals).length}, need at least 2`);
    }
    
    // Select best
    const best = this.selectBest(proposals);
    console.log(`\n🏆 Best initial proposal: ${best.model}`);
    console.log(`   Score: ${best.score}`);
    
    // Round 2: Improvements
    console.log('\n🔄 ROUND 2: Collaborative Improvements\n');
    const improvements = await this.getImprovements(best, question, projectPath);
    
    // Synthesize with c1 if available, otherwise merge
    console.log('\n🔧 SYNTHESIS: Creating final solution\n');
    const final = await this.synthesizeWithArbitrator(best, improvements, question);
    
    // Save log
    await this.saveLog(question, projectPath, proposals, best, improvements, final);
    
    return {
      solution: final,
      winner: best.model,
      contributors: Object.keys(improvements)
    };
  }

  /**
   * Get proposals from each model
   */
  async getProposals(question, projectPath) {
    const proposals = {};
    
    for (const model of this.models) {
      console.log(`  Running ${model.name}...`);
      
      const prompt = `Task: ${question}

Your role: ${model.role}
Your expertise: ${model.expertise}

Provide a complete solution focusing on your area of expertise.
Include code examples and best practices.`;
      
      try {
        const result = await this.runModel(model, prompt);
        proposals[model.name] = result;
        console.log(`  ✅ ${model.name} completed`);
      } catch (error) {
        console.log(`  ⚠️ ${model.name} failed:`, error.message);
      }
    }
    
    return proposals;
  }

  /**
   * Run a model with prompt
   */
  async runModel(model, prompt) {
    // Get the actual command to run
    const command = typeof model === 'string' ? model : model.command;
    const alias = typeof model === 'string' ? model : model.alias;
    
    // Save prompt to file to avoid shell escaping issues
    const promptFile = path.join(this.tempDir, `prompt_${alias}_${Date.now()}.txt`);
    await fs.writeFile(promptFile, prompt);
    
    try {
      // Check if proxy is running for better models
      const proxyRunning = await this.checkProxyStatus();
      
      if (!proxyRunning) {
        console.log(`  ⚠️ Proxy not running, using fallback for ${alias}`);
      }
      
      // Run model via alias with proper environment
      // k1-k4 now use Claude CLI with proxy for full MCP access
      const { stdout } = await exec(
        `source ~/.claude-k-models 2>/dev/null; cd ${process.cwd()} && cat "${promptFile}" | ${command} 2>/dev/null`,
        { 
          shell: '/bin/bash',
          timeout: 1800000,  // 30 minutes
          maxBuffer: 50 * 1024 * 1024,
          cwd: process.cwd(),
          env: {
            ...process.env,
            MODEL_OVERRIDE: alias  // Pass model selection to proxy
          }
        }
      );
      
      return stdout || 'No response';
    } catch (error) {
      throw new Error(`Model ${alias} failed: ${error.message}`);
    } finally {
      await fs.unlink(promptFile).catch(() => {});
    }
  }
  
  /**
   * Check if proxy server is running
   */
  async checkProxyStatus() {
    try {
      const { stdout } = await exec('curl -s http://localhost:3456/health 2>/dev/null');
      return stdout.includes('ok');
    } catch {
      return false;
    }
  }

  /**
   * Select best proposal
   */
  selectBest(proposals) {
    let best = null;
    let maxLength = 0;
    
    for (const [model, proposal] of Object.entries(proposals)) {
      // Simple heuristic: longer, more detailed response is better
      const score = proposal.length + 
        (proposal.match(/```/g) || []).length * 500 + // code blocks
        (proposal.match(/\.(js|ts|py)/g) || []).length * 100; // file mentions
      
      if (score > maxLength) {
        maxLength = score;
        best = { model, proposal, score };
      }
    }
    
    return best;
  }

  /**
   * Get improvements from other models
   */
  async getImprovements(best, question, projectPath) {
    const improvements = {};
    
    for (const model of this.models) {
      if (model.name === best.model) continue;
      
      console.log(`  ${model.name} reviewing...`);
      
      const prompt = `The task was: ${question}

Current solution:
${best.proposal.substring(0, 2000)}...

Provide specific improvements based on your expertise: ${model.role}
Focus on what's missing or could be better.`;
      
      try {
        const result = await this.runModel(model, prompt);
        improvements[model.name] = result;
        console.log(`  ✅ ${model.name} provided improvements`);
      } catch (error) {
        console.log(`  ⚠️ ${model.name} couldn't provide improvements`);
      }
    }
    
    return improvements;
  }

  /**
   * Synthesize with c1 arbitrator if available
   */
  async synthesizeWithArbitrator(best, improvements, question) {
    // Try to use c1 (Opus) as arbitrator for final synthesis
    try {
      const synthesisPrompt = `You are synthesizing a multi-model consensus solution.

Original question: ${question}

Best initial solution from ${best.model}:
${best.proposal.substring(0, 3000)}

Improvements suggested by other models:
${Object.entries(improvements).map(([m, i]) => `${m}: ${i.substring(0, 1000)}`).join('\n\n')}

Synthesize these into a final, coherent solution.
Combine the best ideas, resolve conflicts, and provide the optimal approach.
Focus on practical implementation.`;
      
      console.log('  Using c1 (Opus) for final synthesis...');
      const synthesized = await this.runModel('c1', synthesisPrompt);
      return synthesized;
      
    } catch (error) {
      console.log('  c1 not available, using basic synthesis');
      return this.basicSynthesize(best, improvements);
    }
  }
  
  /**
   * Basic synthesis without arbitrator
   */
  basicSynthesize(best, improvements) {
    let final = `## Consensus Solution\n\n`;
    final += `Base: ${best.model} (score: ${best.score})\n`;
    final += `Contributors: ${Object.keys(improvements).join(', ')}\n\n`;
    final += `### Core Solution\n\n${best.proposal}\n\n`;
    
    if (Object.keys(improvements).length > 0) {
      final += `### Enhancements from Other Models\n\n`;
      for (const [model, imp] of Object.entries(improvements)) {
        // Extract actionable improvements
        const useful = this.extractActionableItems(imp);
        if (useful) {
          final += `#### ${model}:\n${useful}\n\n`;
        }
      }
    }
    
    return final;
  }
  
  /**
   * Extract actionable items from improvement text
   */
  extractActionableItems(text) {
    const lines = text.split('\n');
    const actionable = [];
    let inCodeBlock = false;
    
    for (const line of lines) {
      if (line.includes('```')) {
        inCodeBlock = !inCodeBlock;
        actionable.push(line);
      } else if (inCodeBlock) {
        actionable.push(line);
      } else if (
        line.match(/^\s*[-*]/) ||  // Bullet points
        line.match(/^\s*\d+\./) ||  // Numbered lists
        line.toLowerCase().includes('add') ||
        line.toLowerCase().includes('fix') ||
        line.toLowerCase().includes('implement') ||
        line.toLowerCase().includes('test')
      ) {
        actionable.push(line);
      }
    }
    
    const result = actionable.slice(0, 20).join('\n').trim();
    return result.length > 50 ? result : null;
  }

  /**
   * Save debate log
   */
  async saveLog(question, projectPath, proposals, best, improvements, final) {
    try {
      await fs.mkdir(this.logsDir, { recursive: true });
      const logFile = path.join(this.logsDir, `debate_${Date.now()}.json`);
      
      const log = {
        timestamp: new Date().toISOString(),
        question,
        projectPath,
        models: this.models.map(m => m.name),
        winner: best.model,
        score: best.score,
        proposalCount: Object.keys(proposals).length,
        improvementCount: Object.keys(improvements).length,
        finalLength: final.length
      };
      
      await fs.writeFile(logFile, JSON.stringify(log, null, 2));
      console.log(`📝 Log saved: ${logFile}`);
    } catch (error) {
      console.warn('Could not save log:', error.message);
    }
  }
  
  async cleanup() {
    await fs.rm(this.tempDir, { recursive: true, force: true }).catch(() => {});
  }
}

module.exports = { SimpleDebate };